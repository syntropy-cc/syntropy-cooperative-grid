package usb

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"syntropy-cc/cooperative-grid/infrastructure"
)

// Config cont√©m configura√ß√µes para cria√ß√£o de USB
type Config struct {
	NodeName        string `json:"node_name"`
	NodeDescription string `json:"node_description"`
	Coordinates     string `json:"coordinates"`
	OwnerKeyFile    string `json:"owner_key_file"`
	Label           string `json:"label"`
}

// Creator interface para cria√ß√£o de USB com boot
type Creator interface {
	CreateUSB(devicePath string, config *Config) error
	Cleanup() error
}

// USBCreator implementa a cria√ß√£o de USB com boot
type USBCreator struct {
	workDir     string
	cacheDir    string
	formatter   Formatter
	templateMgr *infrastructure.TemplateManager
	keyMgr      *infrastructure.KeyManager
}

// NewCreator cria uma nova inst√¢ncia do criador de USB
func NewCreator(workDir, cacheDir string) *USBCreator {
	// Determinar diret√≥rio de templates baseado na estrutura do projeto
	templateDir := "infrastructure"
	if _, err := os.Stat(templateDir); os.IsNotExist(err) {
		// Se n√£o existe no diret√≥rio atual, tentar relativo ao projeto
		templateDir = "../../infrastructure"
	}

	// Criar diret√≥rio de chaves dentro do workDir
	keyDir := filepath.Join(workDir, "keys")

	return &USBCreator{
		workDir:     workDir,
		cacheDir:    cacheDir,
		formatter:   NewFormatter(),
		templateMgr: infrastructure.NewTemplateManager(templateDir),
		keyMgr:      infrastructure.NewKeyManager(keyDir),
	}
}

// CreateUSB orquestra o processo completo de cria√ß√£o do USB
func (c *USBCreator) CreateUSB(devicePath string, config *Config) error {
	fmt.Println("üöÄ Iniciando cria√ß√£o de USB com boot para Syntropy Cooperative Grid")
	fmt.Println()

	// Validar configura√ß√£o
	if err := c.validateConfig(config); err != nil {
		return fmt.Errorf("configura√ß√£o inv√°lida: %w", err)
	}

	// Criar diret√≥rios de trabalho
	if err := c.setupDirectories(); err != nil {
		return fmt.Errorf("falha ao criar diret√≥rios: %w", err)
	}

	// Etapa 1: Formatar dispositivo USB
	fmt.Println("üì± Etapa 1/6: Formatando dispositivo USB...")
	if err := c.formatDevice(devicePath, config.Label); err != nil {
		return fmt.Errorf("falha na formata√ß√£o: %w", err)
	}
	fmt.Println("   ‚úÖ Dispositivo formatado com sucesso")
	fmt.Println()

	// Etapa 2: Montar parti√ß√£o
	fmt.Println("üîó Etapa 2/6: Montando parti√ß√£o...")
	mountPoint, err := c.mountPartition(devicePath)
	if err != nil {
		return fmt.Errorf("falha ao montar parti√ß√£o: %w", err)
	}
	defer c.unmountPartition(mountPoint)
	fmt.Printf("   ‚úÖ Parti√ß√£o montada em %s\n", mountPoint)
	fmt.Println()

	// Etapa 3: Download e instala√ß√£o do Ubuntu
	fmt.Println("‚¨áÔ∏è  Etapa 3/6: Baixando e instalando Ubuntu Server...")
	isoPath, err := c.downloadUbuntuISO()
	if err != nil {
		return fmt.Errorf("falha no download do Ubuntu: %w", err)
	}
	defer os.Remove(isoPath)

	if err := c.installUbuntuToUSB(mountPoint, isoPath); err != nil {
		return fmt.Errorf("falha na instala√ß√£o do Ubuntu: %w", err)
	}
	fmt.Println("   ‚úÖ Ubuntu Server instalado com sucesso")
	fmt.Println()

	// Etapa 4: Configurar boot
	fmt.Println("üîß Etapa 4/6: Configurando boot...")
	if err := c.configureBoot(mountPoint); err != nil {
		return fmt.Errorf("falha na configura√ß√£o de boot: %w", err)
	}
	fmt.Println("   ‚úÖ Boot configurado com sucesso")
	fmt.Println()

	// Etapa 5: Gerar chaves SSH
	fmt.Println("üîë Etapa 5/6: Gerando chaves SSH...")
	nodeKeyPath, err := c.generateSSHKeys(mountPoint, config.NodeName)
	if err != nil {
		return fmt.Errorf("falha na gera√ß√£o de chaves: %w", err)
	}
	fmt.Printf("   ‚úÖ Chaves SSH geradas: %s\n", nodeKeyPath)
	fmt.Println()

	// Etapa 6: Criar configura√ß√£o cloud-init usando IaC
	fmt.Println("‚òÅÔ∏è  Etapa 6/6: Criando configura√ß√£o cloud-init usando Infrastructure as Code...")
	if err := c.createCloudInitWithIAC(mountPoint, config); err != nil {
		return fmt.Errorf("falha na cria√ß√£o do cloud-init: %w", err)
	}
	fmt.Println("   ‚úÖ Configura√ß√£o cloud-init criada com sucesso usando IaC")
	fmt.Println()

	fmt.Println("üéâ USB com boot criado com sucesso!")
	fmt.Printf("   N√≥: %s\n", config.NodeName)
	fmt.Printf("   Dispositivo: %s\n", devicePath)
	fmt.Printf("   Montado em: %s\n", mountPoint)
	fmt.Println()
	fmt.Println("üìã Pr√≥ximos passos:")
	fmt.Println("   1. Desmonte o USB com seguran√ßa")
	fmt.Println("   2. Insira no hardware alvo")
	fmt.Println("   3. Configure boot para USB no BIOS/UEFI")
	fmt.Println("   4. A instala√ß√£o ser√° autom√°tica (~30 minutos)")

	return nil
}

// validateConfig valida a configura√ß√£o fornecida
func (c *USBCreator) validateConfig(config *Config) error {
	if config.NodeName == "" {
		return fmt.Errorf("nome do n√≥ √© obrigat√≥rio")
	}

	// Validar formato do nome do n√≥
	if !isValidNodeName(config.NodeName) {
		return fmt.Errorf("nome do n√≥ inv√°lido: %s (deve conter apenas letras, n√∫meros e h√≠fens)", config.NodeName)
	}

	// Validar coordenadas se fornecidas
	if config.Coordinates != "" && !isValidCoordinates(config.Coordinates) {
		return fmt.Errorf("coordenadas inv√°lidas: %s (formato esperado: lat,lon)", config.Coordinates)
	}

	return nil
}

// setupDirectories cria os diret√≥rios necess√°rios
func (c *USBCreator) setupDirectories() error {
	dirs := []string{c.workDir, c.cacheDir}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("falha ao criar diret√≥rio %s: %w", dir, err)
		}
	}

	return nil
}

// formatDevice formata o dispositivo USB
func (c *USBCreator) formatDevice(devicePath, label string) error {
	return c.formatter.FormatDevice(devicePath, label)
}

// mountPartition monta a parti√ß√£o do USB
func (c *USBCreator) mountPartition(devicePath string) (string, error) {
	// Determinar o caminho da parti√ß√£o
	partitionPath := c.getPartitionPath(devicePath)
	if partitionPath == "" {
		return "", fmt.Errorf("n√£o foi poss√≠vel determinar o caminho da parti√ß√£o")
	}

	// Criar ponto de montagem
	mountPoint := filepath.Join(c.workDir, "mount")
	if err := os.MkdirAll(mountPoint, 0755); err != nil {
		return "", fmt.Errorf("falha ao criar ponto de montagem: %w", err)
	}

	// Montar a parti√ß√£o
	cmd := exec.Command("sudo", "mount", partitionPath, mountPoint)
	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("falha ao montar parti√ß√£o: %w", err)
	}

	return mountPoint, nil
}

// unmountPartition desmonta a parti√ß√£o
func (c *USBCreator) unmountPartition(mountPoint string) {
	cmd := exec.Command("sudo", "umount", mountPoint)
	cmd.Run() // Ignorar erro
	os.RemoveAll(mountPoint)
}

// downloadUbuntuISO baixa o Ubuntu Server ISO
func (c *USBCreator) downloadUbuntuISO() (string, error) {
	isoPath := filepath.Join(c.cacheDir, "ubuntu-22.04.3-live-server-amd64.iso")

	// Verificar se j√° existe
	if _, err := os.Stat(isoPath); err == nil {
		fmt.Printf("   ‚úÖ ISO j√° existe em cache: %s\n", isoPath)
		return isoPath, nil
	}

	fmt.Printf("   üì• Baixando Ubuntu Server ISO...\n")
	fmt.Printf("   üìç Destino: %s\n", isoPath)

	// URL do Ubuntu Server 22.04.3 LTS
	url := "https://releases.ubuntu.com/22.04.3/ubuntu-22.04.3-live-server-amd64.iso"

	// Criar arquivo de destino
	file, err := os.Create(isoPath)
	if err != nil {
		return "", fmt.Errorf("falha ao criar arquivo ISO: %w", err)
	}
	defer file.Close()

	// Fazer download
	resp, err := http.Get(url)
	if err != nil {
		return "", fmt.Errorf("falha ao baixar ISO: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("falha no download: status %d", resp.StatusCode)
	}

	// Copiar dados
	if _, err := io.Copy(file, resp.Body); err != nil {
		return "", fmt.Errorf("falha ao salvar ISO: %w", err)
	}

	fmt.Printf("   ‚úÖ Download conclu√≠do: %s\n", isoPath)
	return isoPath, nil
}

// installUbuntuToUSB instala o Ubuntu no USB
func (c *USBCreator) installUbuntuToUSB(mountPoint, isoPath string) error {
	fmt.Printf("   üì¶ Extraindo ISO para USB...\n")

	// Criar ponto de montagem tempor√°rio para o ISO
	isoMountPoint := filepath.Join(c.workDir, "iso-mount")
	if err := os.MkdirAll(isoMountPoint, 0755); err != nil {
		return fmt.Errorf("falha ao criar ponto de montagem do ISO: %w", err)
	}
	defer os.RemoveAll(isoMountPoint)

	// Montar ISO
	cmd := exec.Command("sudo", "mount", "-o", "loop", isoPath, isoMountPoint)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("falha ao montar ISO: %w", err)
	}
	defer exec.Command("sudo", "umount", isoMountPoint).Run()

	// Copiar arquivos do ISO para o USB
	fmt.Printf("   üìã Copiando arquivos do sistema...\n")

	// Copiar arquivos principais
	filesToCopy := []string{
		"casper/",
		"dists/",
		"install/",
		"pool/",
		"EFI/",
		".disk/",
		"isolinux/",
		"[BOOT]/",
	}

	for _, file := range filesToCopy {
		src := filepath.Join(isoMountPoint, file)
		dst := filepath.Join(mountPoint, file)

		if _, err := os.Stat(src); err == nil {
			cmd := exec.Command("sudo", "cp", "-r", src, dst)
			if err := cmd.Run(); err != nil {
				fmt.Printf("   ‚ö†Ô∏è  Aviso: Falha ao copiar %s: %v\n", file, err)
			}
		}
	}

	// Copiar arquivos de boot espec√≠ficos
	bootFiles := []string{
		"boot/grub/grub.cfg",
		"boot/grub/loopback.cfg",
		"md5sum.txt",
	}

	for _, file := range bootFiles {
		src := filepath.Join(isoMountPoint, file)
		dst := filepath.Join(mountPoint, file)

		if _, err := os.Stat(src); err == nil {
			cmd := exec.Command("sudo", "cp", src, dst)
			cmd.Run() // Ignorar erro
		}
	}

	fmt.Printf("   ‚úÖ Arquivos do sistema copiados\n")
	return nil
}

// configureBoot configura o boot do USB
func (c *USBCreator) configureBoot(mountPoint string) error {
	fmt.Printf("   üîß Configurando GRUB...\n")

	// Instalar GRUB no USB
	cmd := exec.Command("sudo", "grub-install", "--target=i386-pc", "--boot-directory="+filepath.Join(mountPoint, "boot"), "--force", c.getDeviceFromMount(mountPoint))
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("falha ao instalar GRUB: %w", err)
	}

	// Criar configura√ß√£o GRUB personalizada
	grubCfg := filepath.Join(mountPoint, "boot/grub/grub.cfg")
	grubConfig := c.generateGRUBConfig()

	if err := os.WriteFile(grubCfg, []byte(grubConfig), 0644); err != nil {
		return fmt.Errorf("falha ao criar configura√ß√£o GRUB: %w", err)
	}

	fmt.Printf("   ‚úÖ GRUB configurado com sucesso\n")
	return nil
}

// generateOrLoadSSHKeys gera ou carrega chaves SSH
func (c *USBCreator) generateOrLoadSSHKeys(keyFilePath, nodeName string, purpose infrastructure.KeyPurpose) (*infrastructure.KeyPair, *infrastructure.KeyPair, error) {
	var keyPair *infrastructure.KeyPair
	var err error

	if keyFilePath != "" && keyFilePath != "" {
		// Carregar chaves existentes
		keyPair, err = c.keyMgr.LoadExistingKeyPair(keyFilePath)
		if err != nil {
			return nil, nil, fmt.Errorf("falha ao carregar chaves existentes: %w", err)
		}
	} else {
		// Gerar novas chaves
		keyPair, err = c.keyMgr.GenerateKeyPair(purpose, nodeName)
		if err != nil {
			return nil, nil, fmt.Errorf("falha ao gerar novas chaves: %w", err)
		}

		// Salvar chaves geradas
		if err := c.keyMgr.SaveKeyPair(keyPair, purpose, nodeName); err != nil {
			return nil, nil, fmt.Errorf("falha ao salvar chaves geradas: %w", err)
		}
	}

	// Retornar o mesmo par como privada e p√∫blica (estrutura do KeyPair j√° cont√©m ambas)
	return keyPair, keyPair, nil
}

// generateSSHKeys gera chaves SSH para o n√≥
func (c *USBCreator) generateSSHKeys(mountPoint, nodeName string) (string, error) {
	fmt.Printf("   üîë Gerando chave SSH RSA 4096-bit...\n")

	// Criar diret√≥rio para chaves
	keysDir := filepath.Join(mountPoint, "syntropy", "keys")
	if err := os.MkdirAll(keysDir, 0750); err != nil {
		return "", fmt.Errorf("falha ao criar diret√≥rio de chaves: %w", err)
	}

	// Gerar chave privada
	privateKeyPath := filepath.Join(keysDir, nodeName+".key")
	cmd := exec.Command("ssh-keygen", "-t", "rsa", "-b", "4096", "-f", privateKeyPath, "-N", "", "-C", nodeName)
	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("falha ao gerar chave privada: %w", err)
	}

	// Gerar chave p√∫blica
	publicKeyPath := privateKeyPath + ".pub"
	cmd = exec.Command("ssh-keygen", "-y", "-f", privateKeyPath)
	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("falha ao gerar chave p√∫blica: %w", err)
	}

	if err := os.WriteFile(publicKeyPath, output, 0644); err != nil {
		return "", fmt.Errorf("falha ao salvar chave p√∫blica: %w", err)
	}

	// Gerar fingerprint
	fingerprintCmd := exec.Command("ssh-keygen", "-lf", privateKeyPath)
	fingerprintOutput, err := fingerprintCmd.Output()
	if err == nil {
		fingerprintPath := filepath.Join(keysDir, nodeName+".fingerprint")
		os.WriteFile(fingerprintPath, fingerprintOutput, 0644)
	}

	fmt.Printf("   ‚úÖ Chaves SSH geradas com sucesso\n")
	fmt.Printf("   üìç Chave privada: %s\n", privateKeyPath)
	fmt.Printf("   üìç Chave p√∫blica: %s\n", publicKeyPath)

	return privateKeyPath, nil
}

// createCloudInitWithIAC cria a configura√ß√£o cloud-init usando Infrastructure as Code
func (c *USBCreator) createCloudInitWithIAC(mountPoint string, config *Config) error {
	fmt.Printf("   ‚òÅÔ∏è  Criando configura√ß√£o cloud-init usando IaC...\n")

	// Criar diret√≥rio cloud-init
	cloudInitDir := filepath.Join(mountPoint, "cloud-init")
	if err := os.MkdirAll(cloudInitDir, 0755); err != nil {
		return fmt.Errorf("falha ao criar diret√≥rio cloud-init: %w", err)
	}

	// Gerar ou carregar chaves SSH
	ownerKey, ownerPub, err := c.generateOrLoadSSHKeys(config.OwnerKeyFile, config.NodeName, infrastructure.OwnerKey)
	if err != nil {
		return fmt.Errorf("falha ao gerar chaves do propriet√°rio: %w", err)
	}

	communityKey, communityPub, err := c.generateOrLoadSSHKeys("", config.NodeName, infrastructure.CommunityKey)
	if err != nil {
		return fmt.Errorf("falha ao gerar chaves da comunidade: %w", err)
	}

	// Preparar dados para o template
	templateData := &infrastructure.TemplateData{
		NodeName:                 config.NodeName,
		NodeDescription:          config.NodeDescription,
		Coordinates:              config.Coordinates,
		CreatedAt:                time.Now().Format(time.RFC3339),
		AdminPasswordHash:        "$6$rounds=4096$syntropy$N8mVzFK0Y1OelT1SKEjg0jIXzKMzL3ZcOGcE5xR8nS6E8qSO5qFV6eJs1g7T6E0cC7w.kfNO3FqC3YhE9Gz19.",
		OwnerPublicKey:           ownerPub.PublicKey,
		CommunityPublicKey:       communityPub.PublicKey,
		KeyInstallationCommands:  c.keyMgr.GenerateKeyInstallationCommands(ownerKey, ownerPub, communityKey, communityPub),
		MetadataCreationCommands: c.keyMgr.GenerateMetadataCreationCommands(config.NodeName, config.Coordinates, config.NodeDescription),
		TemplateCreationCommands: c.generateTemplateCreationCommands(),
		StartupServiceCommands:   c.generateStartupServiceCommands(config.NodeName),
		NodeID:                   generateInstanceID(),
		LocationNodeID:           generateInstanceID(),
		DetectionMethod:          "manual",
		DetectedCity:             "Unknown",
		DetectedCountry:          "Unknown",
		OwnerFingerprint:         ownerKey.Fingerprint,
		CommunityFingerprint:     communityKey.Fingerprint,
	}

	// Gerar arquivos cloud-init usando templates IaC
	if err := c.templateMgr.SaveCloudInitFiles(cloudInitDir, templateData); err != nil {
		return fmt.Errorf("falha ao gerar arquivos cloud-init: %w", err)
	}

	fmt.Printf("   ‚úÖ Configura√ß√£o cloud-init criada usando IaC\n")
	fmt.Printf("   üìç user-data: %s\n", filepath.Join(cloudInitDir, "user-data"))
	fmt.Printf("   üìç meta-data: %s\n", filepath.Join(cloudInitDir, "meta-data"))
	fmt.Printf("   üìç network-config: %s\n", filepath.Join(cloudInitDir, "network-config"))

	return nil
}

// generateGRUBConfig gera configura√ß√£o GRUB
func (c *USBCreator) generateGRUBConfig() string {
	return `set timeout=10
set default=0

menuentry "Ubuntu Server (Syntropy Cooperative Grid)" {
    set gfxpayload=keep
    linux /casper/vmlinuz quiet autoinstall ds=nocloud
    initrd /casper/initrd
}

menuentry "Ubuntu Server (Manual Install)" {
    set gfxpayload=keep
    linux /casper/vmlinuz
    initrd /casper/initrd
}
`
}

// generateCloudInitConfig gera configura√ß√£o cloud-init
func (c *USBCreator) generateCloudInitConfig(config *Config) string {
	return fmt.Sprintf(`#cloud-config
# Syntropy Cooperative Grid Node Configuration
# Node: %s
# Generated: %s

users:
  - name: syntropy
    groups: sudo, docker
    shell: /bin/bash
    sudo: ['ALL=(ALL) NOPASSWD:ALL']
    ssh_authorized_keys:
      - %s

package_update: true
package_upgrade: true

packages:
  - docker.io
  - docker-compose
  - curl
  - wget
  - git
  - htop
  - fail2ban
  - ufw

runcmd:
  - systemctl enable docker
  - systemctl start docker
  - usermod -aG docker syntropy
  - ufw --force enable
  - ufw allow ssh
  - ufw allow 80/tcp
  - ufw allow 443/tcp
  - systemctl enable fail2ban
  - systemctl start fail2ban
  - echo "Syntropy Cooperative Grid Node: %s" > /etc/motd

write_files:
  - path: /etc/syntropy/node.conf
    content: |
      node_name=%s
      node_description=%s
      coordinates=%s
      created_at=%s
    permissions: '0644'
    owner: root:root

final_message: "Syntropy Cooperative Grid Node %s installed successfully!"
`, config.NodeName, time.Now().Format(time.RFC3339),
		c.getSSHPublicKey(config), config.NodeName, config.NodeName,
		config.NodeDescription, config.Coordinates, time.Now().Format(time.RFC3339), config.NodeName)
}

// generateMetaData gera meta-data
func (c *USBCreator) generateMetaData(config *Config) string {
	return fmt.Sprintf(`instance-id: %s
local-hostname: %s
`, generateInstanceID(), config.NodeName)
}

// Fun√ß√µes auxiliares

func (c *USBCreator) getPartitionPath(devicePath string) string {
	// Tentar diferentes padr√µes
	patterns := []string{
		devicePath + "1",
		devicePath + "p1",
	}

	for _, pattern := range patterns {
		if _, err := os.Stat(pattern); err == nil {
			return pattern
		}
	}
	return ""
}

func (c *USBCreator) getDeviceFromMount(mountPoint string) string {
	// Implementa√ß√£o simples - em produ√ß√£o usar /proc/mounts
	return "/dev/sdb" // Placeholder
}

func (c *USBCreator) getSSHPublicKey(config *Config) string {
	// Se uma chave de propriet√°rio foi fornecida, usar ela
	if config.OwnerKeyFile != "" {
		if pubKey, err := os.ReadFile(config.OwnerKeyFile + ".pub"); err == nil {
			return strings.TrimSpace(string(pubKey))
		}
	}

	// Caso contr√°rio, gerar uma chave tempor√°ria
	return "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC..." // Placeholder
}

func isValidNodeName(name string) bool {
	// Nome deve conter apenas letras, n√∫meros e h√≠fens
	for _, char := range name {
		if !((char >= 'a' && char <= 'z') ||
			(char >= 'A' && char <= 'Z') ||
			(char >= '0' && char <= '9') ||
			char == '-') {
			return false
		}
	}
	return len(name) > 0 && len(name) <= 63
}

func isValidCoordinates(coords string) bool {
	// Formato esperado: lat,lon (ex: -23.5505,-46.6333)
	parts := strings.Split(coords, ",")
	if len(parts) != 2 {
		return false
	}

	// Validar latitude (-90 a 90)
	lat := strings.TrimSpace(parts[0])
	if lat == "" {
		return false
	}

	// Validar longitude (-180 a 180)
	lon := strings.TrimSpace(parts[1])
	if lon == "" {
		return false
	}

	return true
}

func generateInstanceID() string {
	bytes := make([]byte, 8)
	rand.Read(bytes)
	return hex.EncodeToString(bytes)
}

// Cleanup limpa arquivos tempor√°rios
func (c *USBCreator) Cleanup() error {
	// Limpar diret√≥rio de trabalho
	if err := os.RemoveAll(c.workDir); err != nil {
		return fmt.Errorf("falha ao limpar diret√≥rio de trabalho: %w", err)
	}
	return nil
}
